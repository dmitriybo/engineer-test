# Решение тестового задания

## 1. Принятые архитектурные решения

### 1.1 Выбор подхода: Материализованные представления + Кеширование

Задача - частое чтение, редкая запись, БД как узкое место. Выбрал комбинацию:

**Материализованные представления**
- Предвычисленные результаты хранятся в БД как отдельные документы
- Тип `employeeWithCity_view` для метода `employeeWithCityList()`
- Тип `employeeWithPosition_view` для метода `employeeWithPositionList()`

**Кеш справочников в памяти**
- City, Division, Position загружаются при старте
- Справочники редко меняются, занимают мало места
- Используются для построения материализованных представлений

### 1.2 Обоснование решения

**Анализ количества запросов к БД:**

| Подход | employeeWithCityList() | employeeWithPositionList() |
|--------|------------------------|----------------------------|
| Нормализация | 1 + N запросов | 1 + 2N запросов |
| Полная денормализация | 1 запрос | 1 запрос |
| Материализованные представления | 1 запрос | 1 запрос |

Для 1000 сотрудников:
- Нормализация: 1001-3001 запросов к БД
- Материализация: 2 запроса
- Выигрыш: в 500-1500 раз меньше обращений

### 1.3 Плюсы и минусы

**Плюсы:**
- Минимальное количество запросов к БД при чтении
- Очень быстрое чтение данных
- Простота кода для операций чтения

**Минусы:**
- Увеличение сложности при обновлении данных
- Дублирование данных (больше места в БД)
- Возможна eventual consistency
- Нужен пересчет представлений при изменении справочников

## 2. Структура данных в БД

### 2.1 Нормализованные коллекции (Source of Truth)

**Employee** (type: "employee")
```typescript
{
  uuid: string;         // Уникальный идентификатор
  firstName: string;    // Имя
  lastName: string;     // Фамилия
  divisionUuid: string; // Ссылка на подразделение
  cityUuid: string;     // Ссылка на город
  positionUuid: string; // Ссылка на должность
}
```

**City** (type: "city")
```typescript
{
  uuid: string;  // Уникальный идентификатор
  name: string;  // Название города
}
```

**Division** (type: "division")
```typescript
{
  uuid: string;     // Уникальный идентификатор
  name: string;     // Название подразделения
  cityUuid: string; // Ссылка на город
}
```

**Position** (type: "position")
```typescript
{
  uuid: string;  // Уникальный идентификатор
  name: string;  // Название должности
}
```

### 2.2 Материализованные представления

**EmployeeWithCity_view** (type: "employeeWithCity_view")
```typescript
{
  uuid: string;      // ID сотрудника
  firstName: string; // Имя сотрудника
  city: string;      // Название города (денормализовано)
}
```

**EmployeeWithPosition_view** (type: "employeeWithPosition_view")
```typescript
{
  uuid: string;      // ID сотрудника
  firstName: string; // Имя сотрудника
  position: string;  // Название должности (денормализовано)
  division: string;  // Название подразделения (денормализовано)
}
```


## 3. Производительность и сравнение подходов

### 3.1 Сравнение архитектурных подходов

**Подход 1: Полная нормализация**
- Структура: 4 коллекции (Employee, City, Division, Position)
- Чтение: N+1 или 2N+1 запросов
- Запись: 1 запрос (быстро)
- Место: Минимальное
- Вывод: Не подходит для контекста (много чтений)

**Подход 2: Полная денормализация**
- Структура: 1 коллекция (Employee со всеми данными)
- Чтение: 1 запрос (отлично)
- Запись: N запросов при изменении справочника
- Место: Среднее (дублирование для каждого сотрудника)
- Вывод: Проблемы при обновлении справочников

**Подход 3: Материализованные представления (выбранный)**
- Структура: 4 нормализованных + 2 материализованных коллекции
- Чтение: 1 запрос (отлично)
- Запись: 1-N запросов (нужно обновить представления)
- Место: Максимальное (нормализация + материализация)
- Вывод: Оптимален для нашего контекста

### 3.2 Оценка производительности

Для 10,000 сотрудников, 10 городов, 50 подразделений, 100 должностей:

| Операция | Нормализация | Денормализация | Материализация |
|----------|--------------|----------------|----------------|
| Чтение всех сотрудников с городами | 10,001 запросов | 1 запрос | 1 запрос |
| Чтение всех сотрудников с должностями | 20,001 запросов | 1 запрос | 1 запрос |
| Обновление города у 1 сотрудника | 1 запрос | 1 запрос | 1 + 2 запроса |
| Переименование города | 1 запрос | 10,000 запросов | 1 + ~5,000 запросов |

### 3.3 Время отклика

Если один запрос к БД занимает 10ms:

| Операция | Нормализация | Материализация | Выигрыш |
|----------|--------------|----------------|---------|
| employeeWithCityList() | ~100 сек | 10 ms | 10,000x |
| employeeWithPositionList() | ~200 сек | 10 ms | 20,000x |

## 4. Альтернативный сценарий: частая запись, редкое чтение

### 4.1 Изменение решения

Если контекст изменится на редкие операции чтения и много операций записи, то материализованные представления станут узким местом.

### 4.2 Рекомендуемый подход для write-heavy сценария

**Полная нормализация с индексами**

**Структура:**
- Только нормализованные коллекции (Employee, City, Division, Position)
- Убрать материализованные представления
- Добавить индексы на внешние ключи

**Реализация методов чтения:**
```typescript
async employeeWithCityList() {
  const employees = await db.query({ type: 'employee', where: {} });
  const cityUuids = [...new Set(employees.items.map(e => e.data.cityUuid))];
  const cities = await Promise.all(
    cityUuids.map(uuid => db.query({ type: 'city', where: { uuid } }))
  );
  
  return employees.items.map(emp => ({
    firstName: emp.data.firstName,
    city: cities.find(c => c.uuid === emp.data.cityUuid)?.name
  }));
}
```

**Кеширование с инвалидацией:**
- Кешируем справочники в памяти
- При изменении справочника - сбрасываем кеш
- Применяем TTL для автоматической инвалидации

### 4.3 Сравнение производительности

Write-heavy сценарий: 100 записей на 1 чтение

| Метрика | Материализация | Нормализация |
|---------|----------------|--------------|
| Операций записи (100) | 100 + 200 запросов (пересчет) | 100 запросов |
| Операций чтения (1) | 1 запрос | 1 + 10 запросов |
| Итого запросов | 300 | 110 |
| Вывод | Медленно | Быстрее в 2.7 раза |

### 4.4 Рекомендации для write-heavy сценария

1. Убрать материализованные представления - они замедляют запись
2. Использовать индексы - для ускорения JOIN'ов при чтении
3. Кешировать справочники в памяти
4. Применить батчинг - группировать запросы к БД
5. Рассмотреть in-memory JOIN - выполнять соединения на уровне приложения

## 5. Дополнительные соображения

### 5.1 Масштабирование

**Горизонтальное масштабирование чтения:**
- Материализованные представления можно реплицировать
- Read replicas для материализованных представлений
- CDN для кеширования результатов API

**Оптимизация обновлений:**
- Асинхронное обновление материализованных представлений
- Использование очередей для пересчета
- Incremental updates (обновление только изменившихся записей)

### 5.2 Мониторинг

Рекомендуемые метрики:
- Время отклика на операции чтения
- Количество запросов к БД на операцию
- Размер материализованных представлений
- Время пересчета представлений
- Cache hit rate для справочников